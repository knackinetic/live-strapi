'use strict';

// Public dependencies
const _ = require('lodash');

/**
 * A set of functions called "actions" for `<%= globalID %>`
 */

module.exports = {

  /**
   * Promise to fetch all <%= idPluralized %>.
   *
   * @return {Promise}
   */

  fetchAll: function (params) {
    return new Promise(function(resolve, reject) {
      <%= globalID %>.forge(params).query(params).fetchAll({
        withRelated: _.keys(_.groupBy(_.reject(strapi.models.<%= id %>.associations, {autoPopulate: false}), 'alias'))
      })
        .then(function(<%= idPluralized %>) {
          resolve(<%= idPluralized %>);
        })
        .catch(function(err) {
          reject(err);
        });
    });
  },

  /**
   * Promise to fetch a/an <%= id %>.
   *
   * @return {Promise}
   */

  fetch: function (params) {
    return new Promise(function(resolve, reject) {
      <%= globalID %>.forge(params).fetch({
        withRelated: _.keys(_.groupBy(_.reject(strapi.models.<%= id %>.associations, {autoPopulate: false}), 'alias'))
      })
        .then(function(<%= id %>) {
          resolve(<%= id %>);
        })
        .catch(function(err) {
          reject(err);
        });
    });
  },

  /**
   * Promise to add a/an <%= id %>.
   *
   * @return {Promise}
   */

  add: function (values) {
    return new Promise(function(resolve, reject) {
      <%= globalID %>.forge(values).save()
        .then(function(<%= id %>) {
          resolve(<%= id %>);
        })
        .catch(function(err) {
          reject(err);
        });
    });
  },

  /**
   * Promise to edit a/an <%= id %>.
   *
   * @return {Promise}
   */

  edit: function (params, values) {
    return new Promise(function(resolve, reject) {
      <%= globalID %>.forge(params).save(values, {path: true})
        .then(function(<%= id %>) {
          resolve(<%= id %>);
        })
        .catch(function(err) {
          reject(err);
        });
    });
  },

  /**
   * Promise to remove a/an <%= id %>.
   *
   * @return {Promise}
   */

  remove: function (params) {
    return new Promise(function(resolve, reject) {
      <%= globalID %>.forge(params).destroy()
        .then(function(<%= id %>) {
          resolve(<%= id %>);
        })
        .catch(function(err) {
          reject(err);
        });
    });
  },

  /**
   * Add relation to a specific <%= id %>.
   *
   * @return {Object}
   */

  addRelation: function (params, values) {
    return new Promise(function(resolve, reject) {
      const relation = _.find(strapi.models.<%= id %>.associations, {alias: params.relation});

      if (!_.isEmpty(relation) && _.isArray(values)) {
        switch (relation.nature) {
          case 'manyToOne':
            const data = _.set({}, params.relation, _.first(values));

            <%= globalID %>.forge(_.omit(params, 'relation')).save(data, {path: true})
              .then(function(<%= id %>) {
                resolve(<%= id %>);
              })
              .catch(function(err) {
                reject(err);
              });
          break;
          case 'manyToMany':
            <%= globalID %>.forge(_.omit(params, 'relation'))[params.relation]().attach(values)
              .then(function(<%= id %>) {
                resolve(<%= id %>);
              })
              .catch(function(err) {
                reject(err);
              });
          break;
          default:
        }
      } else {
        reject('Bad request');
      }
    });
  },

  /**
   * Promise to remove a specific entry from a specific <%= id %>.
   *
   * @return {Promise}
   */

  removeRelation: function (params, values) {
    return new Promise(function(resolve, reject) {
      const relation = _.find(strapi.models.<%= id %>.associations, {alias: params.relation});

      if (!_.isEmpty(relation) && _.isArray(values)) {
        switch (relation.nature) {
          case 'manyToOne':
            const data = _.set({}, params.relation, _.first(values));

            <%= globalID %>.forge(_.omit(params, 'relation')).save(data, {path: true})
              .then(function(<%= id %>) {
                resolve(<%= id %>);
              })
              .catch(function(err) {
                reject(err);
              });
          break;
          case 'manyToMany':
            <%= globalID %>.forge(_.omit(params, 'relation'))[params.relation]().detach(values)
              .then(function(<%= id %>) {
                resolve(<%= id %>);
              })
              .catch(function(err) {
                reject(err);
              });
          break;
          default:
        }
      } else {
        reject('Bad request');
      }
    });
  }
};
